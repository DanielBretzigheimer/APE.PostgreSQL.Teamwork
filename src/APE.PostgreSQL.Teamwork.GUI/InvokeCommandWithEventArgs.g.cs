// <auto-generated>
//     This code was generated by the APE CodeGeneration.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
using System.Windows.Input;

namespace APE.PostgreSQL.Teamwork.GUI
{
    // APE.CodeGeneration.Attribute [DependencyProperty(typeof(object), "DataContext", null)]
    // APE.CodeGeneration.Attribute [DependencyProperty(typeof(ICommand), "Command", null)]
    public partial class InvokeCommandWithEventArgs {
        //ncrunch: no coverage start

        //--------------------------------------------------------------------------------
        // generated code for DependencyProperty
        //--------------------------------------------------------------------------------

        /// <summary>
        /// 
        /// </summary>
        public object DataContext
        {
            get { return (object)this.GetValue(DataContextProperty); }
            set { this.SetValue(DataContextProperty, value); }
        }

        // Using a DependencyProperty as the backing store for DataContext.  This enables animation, styling, binding, etc...
        public static readonly System.Windows.DependencyProperty DataContextProperty = System.Windows.DependencyProperty.Register("DataContext", typeof(object), typeof(InvokeCommandWithEventArgs), new System.Windows.PropertyMetadata(null, DataContextChangedCallback));

        static void DataContextChangedCallback(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)
        {
            DataContextChanged(d, e);
        }

        static partial void DataContextChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e);

        /// <summary>
        /// 
        /// </summary>
        public ICommand Command
        {
            get { return (ICommand)this.GetValue(CommandProperty); }
            set { this.SetValue(CommandProperty, value); }
        }

        // Using a DependencyProperty as the backing store for Command.  This enables animation, styling, binding, etc...
        public static readonly System.Windows.DependencyProperty CommandProperty = System.Windows.DependencyProperty.Register("Command", typeof(ICommand), typeof(InvokeCommandWithEventArgs), new System.Windows.PropertyMetadata(null, CommandChangedCallback));

        static void CommandChangedCallback(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e)
        {
            CommandChanged(d, e);
        }

        static partial void CommandChanged(System.Windows.DependencyObject d, System.Windows.DependencyPropertyChangedEventArgs e);

        //ncrunch: no coverage end
    }
}
